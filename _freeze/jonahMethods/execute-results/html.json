{
  "hash": "afc43f4ffa7226a1e5ae7bb3d92f0b17",
  "result": {
    "markdown": "---\ntitle: 'Methods - Jonah Crab'\ndate-modified: '2023-07-24'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\nOur approach here will be to utilize the multiple spatial scales and different metrics of abundance (weight/biomass, in kg, and catch per tow) to identify recurring patterns/trends in the dynamics of Jonah crab in the Gulf of Maine. We start with univariate analysis to assess the dimensionality, nonlinearity, and predictability of the system, and to evaluate if these characteristics differ across the coastline or at different depths. If the univariate analysis indicates that the system has appropriately low-dimensional, nonlinear dynamics, we move on to exploring the potential drivers of Jonah crab abundance, specifically interspecies interactions with Atlantic rock crabs (primarily a competitor with Jonah crabs) and Atlantic sea scallops (primarily a prey species).\n\n## Load packages\n\n::: {.cell}\n\n```{.r .cell-code}\n#Load packages\nlibrary(tidyverse)\nlibrary(lubridate) #date formatting\nlibrary(patchwork) #combining plots\nlibrary(viridis)\nlibrary(rEDM) #EDM\nlibrary(sf) #for spatial data\n```\n:::\n\n\n## Import data\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_tows<-read.csv(\"data/Maine_inshore_trawl/MEtows.csv\") #tow data\ndf_s_cat<- read.csv(\"data/Maine_inshore_trawl/MEscallopCatch.csv\") #scallop catch\ndf_r_cat<- read.csv(\"data/Maine_inshore_trawl/MErockCatch.csv\") #rock crab catch\ndf_j_cat<- read.csv(\"data/Maine_inshore_trawl/MEjonahCatch.csv\") #jonah crab catch\n\nsurveyGrid <-st_read(\"~/Downloads/lab_notebook/Maine/MaineDMR_-_Inshore_Trawl_Survey_Grid\") #CRS: WGS 84/EPSG 4326\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `MaineDMR_-_Inshore_Trawl_Survey_Grid' from data source \n  `/Users/rubykrasnow/Downloads/lab_notebook/Maine/MaineDMR_-_Inshore_Trawl_Survey_Grid' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3698 features and 9 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -70.81288 ymin: 42.86466 xmax: -66.88822 ymax: 44.81316\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\nRename and add variables to survey grid\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveyGrid <- surveyGrid %>% \n  mutate(Region = region_id,\n         Stratum = depth_stra,\n         GridID = grid_id, .keep=\"unused\", .before=last_surve)\n\nsurveyGrid$area <- as.numeric(paste0(surveyGrid$Region, surveyGrid$Stratum))\n```\n:::\n\n\nDefine function cleanCatch and apply to the three catch data files\n\n::: {.cell}\n\n```{.r .cell-code}\ncleanCatch <- function(x) {\n  full_join(x, df_tows) %>%\n    arrange(Survey, Tow_Number) %>% \n    select(-c(\"Stratum\", \"Subsample_Weight_kg\", \"Subsample_Weight_kg_2\", \"Male_Wt_kg\", \"Female_Wt_kg\",\"Date\", \"Surface_WaterTemp_DegC\", \"Surface_Salinity\", \"End_Latitude\",\"End_Longitude\", \"Air_Temp\", \"Tow_Time\")) %>%\n    mutate(Number_Caught = replace_na(Number_Caught,0),\n           Weight_kg = replace_na(Weight_kg,0),\n           Expanded_Catch = replace_na(Expanded_Catch,0),\n           Expanded_Weight_kg = replace_na(Expanded_Weight_kg,0)) %>% \n    mutate(Stratum = Depth_Stratum, Date = date(ymd_hms(Start_Date)), .keep=\"unused\") %>%\n    mutate(area = as.numeric(paste0(Region, Stratum)),.before= Survey)\n}\n\ns_cat_clean_seasons <- cleanCatch(df_s_cat) %>% \nmutate(Common_Name = \"Scallop\")\n\nr_cat_clean_seasons <- cleanCatch(df_r_cat) %>% \n  mutate(Common_Name = \"Rock\")\n\nj_cat_clean_seasons <- cleanCatch(df_j_cat) %>% \n  mutate(Common_Name = \"Jonah\")\n```\n:::\n\n\nReorder columns so the data frames are easier to work with\n\n::: {.cell}\n\n```{.r .cell-code}\n#Reorder columns\ncolOrder<-c(\"area\", \"Survey\", \"Tow_Number\", \"Region\", \"Stratum\", \"Expanded_Catch\", \n            \"Expanded_Weight_kg\", \"Date\", \"Common_Name\", \"Number_Caught\", \"Weight_kg\",\n            \"Start_Latitude\", \"Start_Longitude\",\"Season\",\n            \"Year\",\"Grid\", \"Start_Depth_fathoms\", \"End_Depth_fathoms\",\n            \"Bottom_WaterTemp_DegC\", \"Bottom_Salinity\")\n\nj_cat_clean_seasons <- j_cat_clean_seasons %>% select(all_of(colOrder))\nr_cat_clean_seasons <- r_cat_clean_seasons %>% select(all_of(colOrder))\ns_cat_clean_seasons <- s_cat_clean_seasons %>% select(all_of(colOrder))\n```\n:::\n\n\nDefine a function, summaryCatch, to summarize over tows for each area (area = region/stratum combination) and apply to all three species.\n\n::: {.cell}\n\n```{.r .cell-code}\nsummaryCatch <- function(df) {\n  df %>% group_by(area, Season, Year, Region, Stratum) %>%\n    summarise(avgCatch = mean(Expanded_Catch),\n              avgWt = mean(Expanded_Weight_kg)) \n}\n\n#computes averages for each study area (area = region-stratum combination)\nj_cat_sum_seasons <- summaryCatch(j_cat_clean_seasons)\nr_cat_sum_seasons <- summaryCatch(r_cat_clean_seasons)\ns_cat_sum_seasons <- summaryCatch(s_cat_clean_seasons)\n```\n:::\n\n\nCombine the three separate data frames\n\n::: {.cell}\n\n```{.r .cell-code}\ncatch_seasons <- s_cat_sum_seasons %>% left_join(j_cat_sum_seasons, by=c(\"area\", \"Season\", \"Region\", \"Stratum\", \"Year\"), suffix = c(\"_s\", \"_j\"))\n\ncatch_seasons <- catch_seasons %>% left_join(r_cat_sum_seasons, by=c(\"area\", \"Season\", \"Region\", \"Stratum\", \"Year\")) %>% \n  mutate(avgCatch_r = avgCatch,avgWt_r = avgWt, .keep=\"unused\")\n```\n:::\n\n\nNow make it ~tidy~ and convert area, Species, Season, Region, and Stratum to factors.\n\n::: {.cell}\n\n```{.r .cell-code}\ncatchTidy_seasons <- pivot_longer(catch_seasons, \n                          cols = 6:ncol(catch_seasons)) %>% \n  mutate(Type = case_when(\n    startsWith(name, \"avgCatch_\") ~\"catch\",\n    startsWith(name,\"avgWt_\") ~\"wt\")) %>% \n  mutate(Species = case_when(\n    endsWith(name, \"s\") ~\"scallop\",\n    endsWith(name, \"r\") ~\"rock\",\n    endsWith(name, \"j\") ~\"jonah\"))\n\ncatchTidy_seasons <- catchTidy_seasons %>% \n  mutate(area = as.factor(area), Species = as.factor(Species),Season = as.factor(Season),Region = as.factor(Region), Stratum = as.factor(Stratum)) %>% \n  select(-name)\n```\n:::\n\n\nThe complete function will turn implicit missing values into explicit ones. In this case, Stratum 4 was not surveyed until 2003, so this will add in the appropriate NA values for 2000-2002. We do this for both the tidy version and the original/long version. Turning Fall/Spring and Year into specific dates makes for easier plotting, although they may be slightly different than the original dates that were associated with individual tows.\n\n::: {.cell}\n\n```{.r .cell-code}\ncatch_complete <- complete(data=catch_seasons %>% ungroup(), Region, Stratum, Season, Year) %>% \n  mutate(area = paste(Region, Stratum)) %>% \n  mutate(date=paste(Year, case_when(Season== \"Fall\" ~ \"-11-01\", Season ==\"Spring\" ~\"-05-01\"), sep = \"\"), .before=Region) %>% \n  filter(date != \"2000-05-01\")\n\ncatchTidy_complete<- complete(data = catchTidy_seasons %>% ungroup() %>%  filter(Type==\"catch\"),  Region, Stratum, Season, Year) %>% \n        mutate(area = as.numeric(paste0(Region, Stratum))) %>% \n        mutate(date=paste(Year, case_when(Season== \"Fall\" ~ \"-11-01\", Season ==\"Spring\" ~\"-05-01\"), sep = \"\"), .before=Region) %>% filter(date != \"2000-05-01\")\n```\n:::\n\n\nParse the date column\n\n::: {.cell}\n\n```{.r .cell-code}\ncatch_complete <- catch_complete %>% mutate(date = lubridate::ymd(date))\ncatchTidy_complete <- catchTidy_complete %>% mutate(date = lubridate::ymd(date))\n```\n:::\n\n\nFirst, we look at trends in overall abundance:\n\n::: {.cell}\n\n```{.r .cell-code}\n#line graph of abundance over time by season, no spatial distinction\nggplot(data = catchTidy_seasons %>% filter(Type==\"catch\", Species==\"jonah\") %>% group_by(Year, Season) %>% summarise(value = mean(value)))+geom_line(aes(x=Year, y=value))+facet_wrap(~Season)+theme_classic()+labs(y=\"Abundance (catch/tow)\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nFor comparison, we also plot the catch time series of Jonah crabs alongside rock crabs, both overall and separated by season:\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = catchTidy_complete %>% filter(Type == \"catch\", Species != \"scallop\") %>% group_by(date, Species) %>% \n         summarise(avg = mean(value, na.rm = TRUE)), aes(x=date, y=avg))+geom_line()+facet_wrap(~Species)+labs(y=\"catch\")+theme_classic()\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#a lot more variation in the jonah crabs\n\n\nggplot(data = catchTidy_complete %>% filter(Type == \"catch\", Species != \"scallop\") %>% group_by(Year, Season, Species) %>% \n          summarise(avg = mean(value, na.rm = TRUE)), aes(x=Year, y=avg))+geom_line()+facet_grid(Season~Species)+labs(y=\"catch\")+theme_classic()\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-12-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#a lot more variation in the jonah crabs\n```\n:::\n\n\nFluctuations in catch of rock crabs appear smaller and more regular than for Jonah crabs.\n\nNow we'll incorporate the spatial aspect of the data. We start by looking at abundance of Jonah and rock crabs averaged from 2000-2022,\n\n::: {.cell}\n\n```{.r .cell-code}\nregionsGrid_orig <- surveyGrid %>% group_by(area) %>% summarise(num = n_distinct(GridID))\nregionsGrid <- left_join(regionsGrid_orig, catchTidy_complete %>% filter(Type==\"catch\",) %>% group_by(area, date, Species) %>% summarise(avg = mean(value)))\n\nggplot(data=regionsGrid %>% filter(Species != \"scallop\") %>% group_by(Species, area) %>% summarise(avg = mean(avg)))+geom_sf(aes(fill=avg))+facet_wrap(~Species)+scale_fill_viridis_c()\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nWe can also separate by seasons:\n\n::: {.cell}\n\n```{.r .cell-code}\nregionsGrid_seasons <- left_join(regionsGrid_orig, catchTidy_complete %>% filter(Type==\"catch\",) %>% group_by(area, date, Species, Season) %>% summarise(avg = mean(value)))\n\n#Jonah and rock crabs\nggplot(data=regionsGrid_seasons %>% filter(Species != \"scallop\") %>% group_by(area, Species, Season) %>% summarize(avg = mean(avg, na.rm=TRUE)))+geom_sf(aes(fill=avg))+facet_grid(Season~Species)+scale_fill_viridis_c(option = \"F\", name=\"avg catch\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Jonah crab only\n#ggplot(data=regionsGrid_seasons %>% filter(Species == \"jonah\") %>% group_by(area, Season) %>% summarize(avg = mean(avg)))+geom_sf(aes(fill=avg))+facet_wrap(~Season)+scale_fill_viridis_c()\n```\n:::\n\n\nWe look at seasonal movement by year:\n\n::: {.cell}\n\n```{.r .cell-code}\njonahCatch <- left_join(regionsGrid_orig, catchTidy_complete %>% filter(Species==\"jonah\"))\n\njonahCatchFall <- jonahCatch %>% filter(Season == \"Fall\", Type == \"catch\") %>% rename(valueFall = value) %>% select(-c(\"Season\", \"date\"))\njonahCatchSpring <- jonahCatch %>% filter(Season == \"Spring\", Type == \"catch\") %>% st_drop_geometry() %>% rename(valueSpring = value) %>% select(-c(\"Season\", \"date\"))\n\njonahCatchDiff <- left_join(jonahCatchFall, jonahCatchSpring) %>% arrange(area, Year)\njonahCatchDiff <- jonahCatchDiff %>% mutate(diff = valueFall -valueSpring)\n\n#difference fall vs spring by year\nggplot(data = jonahCatchDiff %>% filter(Type==\"catch\") %>% filter(Year != 2000 & Year != 2020))+geom_sf(aes(fill=diff))+\nscale_fill_viridis_b(name=\"fall catch minus spring catch\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#difference fall vs spring by year and area\nggplot(data = jonahCatchDiff %>% filter(Type==\"catch\") %>% filter(Year != 2000 & Year != 2020))+geom_sf(aes(fill=diff))+\nscale_fill_viridis_b(name=\"fall catch minus spring catch\")+facet_wrap(~Year)\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n\n```{.r .cell-code}\nseasonalDiff_by_area<- jonahCatchDiff %>% st_drop_geometry() %>% group_by(area) %>% summarise(avg = mean(diff, na.rm=TRUE), sd = sd(diff, na.rm=TRUE))\nseasonalDiff_by_area\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 3\n    area     avg    sd\n   <dbl>   <dbl> <dbl>\n 1    11  3.04    7.69\n 2    12  3.39    4.20\n 3    13  2.24    4.50\n 4    14  0.0375  1.90\n 5    21  2.69    4.08\n 6    22  4.55    8.68\n 7    23  1.53   10.7 \n 8    24  1.14    3.21\n 9    31  0.816   2.17\n10    32  0.119   2.01\n11    33  0.362   7.83\n12    34 -2.62    4.39\n13    41 -2.28    5.65\n14    42 -3.17   16.4 \n15    43  1.07    9.93\n16    44  1.26   11.9 \n17    51  3.25   10.8 \n18    52 -1.87   16.1 \n19    53  0.829  17.0 \n20    54 -0.326   7.91\n```\n:::\n:::\n\n\nFor EDM, we want the time series to be as long as possible, so instead of considering seasons separately, we utilize the entire time series but take second-differences (i.e., x(t) = x(t)-x(t-2)) to remove the seasonal effect. Unfortunately, because of COVID, we are also going to get rid of the data after the missed Spring 2020 survey, since we can't take second-differences with NA values and we want to avoid linear interpolation that may obscure nonlinear system dynamics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlag2 <- function(x) {\n  x_lagged <- (x - lag(x, 2))\n  return(x_lagged)\n}  # test with lag2(c(1, 3, 3, 5, 6, 9, 12))\n\ncatch_complete_diff <- catch_complete %>% arrange(date) %>% group_by(area) %>% \n  mutate(across(where(is.double) & !date, lag2)) %>% \n  arrange(area) %>% \n  filter(date != \"2000-11-01\" & date != \"2001-05-01\") %>%  filter(date < as.Date(\"2020-05-01\"))\n\n#Tidy it up\ncomplete_tidy_diff <- pivot_longer(catch_complete_diff,cols = 7:ncol(catch_complete)) %>% \n  mutate(Type = case_when(\n    startsWith(name, \"avgCatch_\") ~\"catch\",\n    startsWith(name,\"avgWt_\") ~\"wt\",\n    startsWith(name,\"avgLogWt\") ~\"logWt\",\n    startsWith(name,\"avgLogCatch\") ~\"logCatch\")) %>% \n  mutate(Species = case_when(\n    endsWith(name, \"s\") ~\"scallop\",\n    endsWith(name, \"r\") ~\"rock\",\n    endsWith(name, \"j\") ~\"jonah\")) %>%\n  mutate(area = as.factor(area), Species = as.factor(Species),\n         Region = as.factor(Region), Type = as.factor(Type),\n         Stratum = as.factor(Stratum)) %>% \n  select(-name)\n```\n:::\n\n\nLet's look at the differenced data:\n\n::: {.cell}\n\n```{.r .cell-code}\n#All areas on one graph, split by species\nggplot(data = complete_tidy_diff %>% \n         filter(Type == \"catch\", Species != \"scallop\"), aes(x=date, y=value, color=area))+geom_line()+facet_wrap(~Species) +labs(y=\"2nd-differenced catch\", x=\"Year\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#Averaged across areas, split by species\nggplot(data = complete_tidy_diff %>% filter(Type == \"catch\", Species != \"scallop\") %>% group_by(date, Species) %>% \n    summarise(avg = mean(value, na.rm = TRUE)), aes(x=date, y=avg))+geom_line()+facet_wrap(~Species)+theme_classic()+labs(y=\"2nd-differenced catch\", x=\"Year\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-17-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#Colored by species, split by area\nggplot(data = complete_tidy_diff %>% filter(Type == \"catch\", Species != \"scallop\"), aes(x=date, y=value, color=Species))+geom_line()+facet_grid(Region~Stratum)+labs(x=\"Depth stratum\", y=\"Region\")+theme(axis.title.x = element_text(margin = margin(t = 10, r = 0, b = 0, l = 0)))\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-17-3.png){width=672}\n:::\n:::\n\n\nAs we noted earlier, there appears to be much more variation in Jonah crab abundance compared to the rock crabs, although not in every area.\n\n# EDM - dimensionality and nonlinearity (aggregate)\nWe start our EDM analyses by looking at the dynamics of the system in aggregate, averaged across all areas. First we look at embedding dimension using Simplex projection with leave-one-out cross-validation:\n\n::: {.cell}\n\n```{.r .cell-code}\nEmbedDimension(dataFrame=complete_tidy_diff %>% filter(Species==\"jonah\", Type==\"catch\") %>% group_by(date) %>% \n                 summarise(avg = mean(value, na.rm = TRUE)) %>% \n                 ungroup() %>% select(date, avg),  columns =\"avg\", target=\"avg\", lib = \"1 37\", pred=\"1 37\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n    E         rho\n1   1 -0.05596228\n2   2  0.08077393\n3   3 -0.16863421\n4   4 -0.16647178\n5   5 -0.31101223\n6   6 -0.24214677\n7   7 -0.29832851\n8   8 -0.48913659\n9   9 -0.30460740\n10 10 -0.46544135\n```\n:::\n\n```{.r .cell-code}\nEmbedDimension(dataFrame=complete_tidy_diff %>% filter(Species==\"jonah\", Type==\"wt\") %>% group_by(date) %>% \n                 summarise(avg = mean(value, na.rm = TRUE)) %>% \n                 ungroup() %>% select(date, avg),  columns =\"avg\", target=\"avg\", lib = \"1 37\", pred=\"1 37\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-18-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n    E         rho\n1   1  0.01170876\n2   2  0.32701089\n3   3 -0.07984101\n4   4 -0.14711141\n5   5 -0.35237277\n6   6 -0.31118525\n7   7 -0.41617082\n8   8 -0.51337192\n9   9 -0.40191052\n10 10 -0.44620445\n```\n:::\n:::\n\n\nThe optimal embedding dimension is the one with the highest predictive skill. For both catch and weight, E=2 has the highest rho value, although neither measure of abundance shows particularly high rho values.\n\nWe will also use S-mapping to evaluate nonlinearity, with E=2:\n\n::: {.cell}\n\n```{.r .cell-code}\nPredictNonlinear(dataFrame=complete_tidy_diff %>% filter(Species==\"jonah\", Type==\"catch\") %>% group_by(date) %>% \n                   summarise(avg = mean(value, na.rm = TRUE)) %>% \n                   ungroup() %>% select(date, avg),  columns =\"avg\", target=\"avg\", lib = \"1 37\", pred=\"1 37\", E=2)\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n   Theta       rho\n1   0.01 0.3989329\n2   0.10 0.4221316\n3   0.30 0.4623918\n4   0.50 0.4839824\n5   0.75 0.4887806\n6   1.00 0.4795676\n7   1.50 0.4501698\n8   2.00 0.4218846\n9   3.00 0.3749288\n10  4.00 0.3397510\n11  5.00 0.3111837\n12  6.00 0.2830714\n13  7.00 0.2520656\n14  8.00 0.2180123\n15  9.00 0.1829936\n```\n:::\n\n```{.r .cell-code}\nPredictNonlinear(dataFrame=complete_tidy_diff %>% filter(Species==\"jonah\", Type==\"wt\") %>% group_by(date) %>% \n                   summarise(avg = mean(value, na.rm = TRUE)) %>% \n                   ungroup() %>% select(date, avg),  columns =\"avg\", target=\"avg\", lib = \"1 37\", pred=\"1 37\", E=2)\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-19-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n   Theta       rho\n1   0.01 0.3904568\n2   0.10 0.4208138\n3   0.30 0.4800092\n4   0.50 0.5171723\n5   0.75 0.5311135\n6   1.00 0.5242665\n7   1.50 0.4966586\n8   2.00 0.4711912\n9   3.00 0.4284449\n10  4.00 0.3915121\n11  5.00 0.3579365\n12  6.00 0.3265041\n13  7.00 0.2954545\n14  8.00 0.2630482\n15  9.00 0.2297665\n```\n:::\n:::\n\n\nWe can see that both catch and weight are better represented by a nonlinear model (theta >0) than a linear one. In addition, the predictive skill of the s-map projections is higher than the Simplex models.\n\nNow we want to see how these characteristics change at different spatial scales.\nWe will first define some useful functions to more efficiently repeat the previous tests:\n\n::: {.cell}\n\n```{.r .cell-code}\n############ Find E and rho - vector input -------------------------------------------------\n\nfindE_v <- function(v, maxE = 7) {\n  lib_vec <- paste(1, length(v))\n  indices <- c(1:length(v))\n  df <- data.frame(indices,v)\n  colnames(df)<-c(\"index\", \"value\")\n  rho_E<- EmbedDimension(dataFrame = df, lib = lib_vec, pred = lib_vec, columns = \"value\",target = \"value\", maxE = maxE)\n  E_out<-rho_E[which.max(rho_E$rho),\"E\"][1]\n  return(E_out)\n}\n\nfindErho_v <- function(v) {\n  lib_vec <- paste(1, length(v))\n  indices <- c(1:length(v))\n  df <- data.frame(indices,v)\n  colnames(df)<-c(\"index\", \"value\")\n  rho_E<- EmbedDimension(dataFrame = df, lib = lib_vec, pred = lib_vec, columns = \"value\",target = \"value\", maxE = 7)\n  rho_out<-rho_E[which.max(rho_E$rho),\"rho\"][1]\n  return(rho_out)\n}\n\n############ Find Theta and rho - vector input -------------------------------------------------\n\nfindTheta_v <- function(v, E) {\n  lib_vec <- paste(1, length(v))\n  indices <- c(1:length(v))\n  df <- data.frame(indices,v)\n  colnames(df)<-c(\"index\", \"value\")\n  rho_Theta<- PredictNonlinear(dataFrame = df, lib = lib_vec, pred = lib_vec, columns = \"value\",target = \"value\", E=E)\n  Theta_out<-rho_Theta[which.max(rho_Theta$rho),\"Theta\"][1]\n  return(Theta_out)\n}\n\nfindThetaRho_v <- function(v, E) {\n  lib_vec <- paste(1, length(v))\n  indices <- c(1:length(v))\n  df <- data.frame(indices,v)\n  colnames(df)<-c(\"index\", \"value\")\n  rho_Theta<- PredictNonlinear(dataFrame = df, lib = lib_vec, pred = lib_vec, columns = \"value\",target = \"value\", E=E)\n  Rho_out<-rho_Theta[which.max(rho_Theta$rho),\"rho\"][1]\n  return(Rho_out)\n}\n\n############ findSpeciesE & findSpeciesErho -------------------------------------------------------\n\n#returns a tibble with the optimal embedding dimension for time series from each region/stratum combination\n#Find species E\nfindSpeciesE <- function(df, season=NULL, type) {\n  if (is.null(season)) {\n    df_out <- df %>% \n      filter(Type == type) %>% \n      group_by(Region, Stratum) %>% \n      select(Year, value) %>%\n      summarise(E_opt = findE_v(value)) %>%\n      pivot_wider(names_from = Stratum, values_from = E_opt) %>% \n      ungroup() %>% \n      select(-Region)\n  }\n  else {\n  \n  df_out <- df %>% \n    filter(Type == type, Season == season) %>% \n    group_by(Region, Stratum) %>% \n    select(Year, value) %>%\n    summarise(E_opt = findE_v(value)) %>%\n    pivot_wider(names_from = Stratum, values_from = E_opt) %>% \n    ungroup() %>% \n    select(-Region) }\n  \n  return(df_out)\n}\n\n#Find predictive skill for Simplex with optimal E\nfindSpeciesErho <- function(df, season=NULL, type) {\n  if (is.null(season)) {\n  df_out <- df %>% \n    filter(Type == type) %>% \n    group_by(Region, Stratum) %>% \n    select(Year, value) %>%\n    summarise(E_opt_rho = findErho_v(value)) %>%\n    pivot_wider(names_from = Stratum, values_from = E_opt_rho) %>% \n    ungroup() %>% \n    select(-Region) }\n  \n  else {\n    df_out <- df %>% \n      filter(Type == type, Season == season) %>% \n      group_by(Region, Stratum) %>% \n      select(Year, value) %>%\n      summarise(E_opt_rho = findErho_v(value)) %>%\n      pivot_wider(names_from = Stratum, values_from = E_opt_rho) %>% \n      ungroup() %>% \n      select(-Region)\n    \n  }\n  return(df_out)\n}\n\n############ findSpeciesTheta -------------------------------------------------------\n\nfindSpeciesTheta <- function(df, season=NULL, type) {\n  df_E <- findSpeciesE(df=df, season=season, type=type)\n  \n  findE <- function (reg, strat) {\n     E <- as.integer(df_E %>% slice(reg) %>% pull(strat))\n    return(E) \n    }\n  \n  if (is.null(season)) {\n    df_out <- df %>%\n      filter(Type == type) %>%\n      mutate(E_row = as.integer(Region), E_col = as.integer(Stratum)) %>% \n      rowwise() %>% \n      mutate(E = findE(reg=E_row, strat=E_col)) %>%\n      group_by(Region, Stratum) %>%\n      summarise(Theta_opt =  findTheta_v(value, E[1])) %>%\n      pivot_wider(names_from = Stratum, values_from = Theta_opt) %>%\n      ungroup() %>%\n      select(-Region) }\n  \n  else {\n      df_out <- df %>%\n        filter(Type == type, Season==season) %>%\n        mutate(E_row = as.integer(Region), E_col = as.integer(Stratum)) %>% \n        rowwise() %>% \n        mutate(E = findE(reg=E_row, strat=E_col)) %>%\n        group_by(Region, Stratum) %>%\n        summarise(Theta_opt =  findTheta_v(value, E[1])) %>%\n        pivot_wider(names_from = Stratum, values_from = Theta_opt) %>%\n        ungroup() %>%\n        select(-Region) }\n  \n  return(df_out)\n}\n#Find predictive skill for s-map with optimal E and theta\nfindSpeciesTheta_rho <- function(df, season=NULL, type) {\n  df_E <- findSpeciesE(df=df, season=season, type=type)\n  \n  findE <- function (reg, strat) {\n    E <- as.integer(df_E %>% slice(reg) %>% pull(strat))\n    return(E) \n  }\n  \n  if (is.null(season)) {\n    df_out <- df %>%\n      filter(Type == type) %>%\n      mutate(E_row = as.integer(Region), E_col = as.integer(Stratum)) %>% \n      rowwise() %>% \n      mutate(E = findE(reg=E_row, strat=E_col)) %>%\n      group_by(Region, Stratum) %>%\n      summarise(Theta_opt =  findThetaRho_v(value, E[1])) %>%\n      pivot_wider(names_from = Stratum, values_from = Theta_opt) %>%\n      ungroup() %>%\n      select(-Region) }\n  \n  else {\n    df_out <- df %>%\n      filter(Type == type, Season==season) %>%\n      mutate(E_row = as.integer(Region), E_col = as.integer(Stratum)) %>% \n      rowwise() %>% \n      mutate(E = findE(reg=E_row, strat=E_col)) %>%\n      group_by(Region, Stratum) %>%\n      summarise(Theta_opt =  findThetaRho_v(value, E[1])) %>%\n      pivot_wider(names_from = Stratum, values_from = Theta_opt) %>%\n      ungroup() %>%\n      select(-Region) }\n  \n  return(df_out)\n}\n```\n:::\n\n\n# EDM - dimensionality and nonlinearity (by area)\nNow we apply the functions to the catch data:\n\n::: {.cell}\n\n```{.r .cell-code}\njonah_catchE <- findSpeciesE(complete_tidy_diff %>% filter(Species==\"jonah\") %>% na.omit(), type=\"catch\") \n```\n\n```{.r .cell-code}\njonah_catchE_rho<- findSpeciesErho(complete_tidy_diff %>% filter(Species==\"jonah\") %>% na.omit(), type=\"catch\")%>% round(digits=3)\n```\n\n```{.r .cell-code}\njonah_catch_theta<- findSpeciesTheta(complete_tidy_diff %>% filter(Species==\"jonah\") %>% na.omit(), type=\"catch\")\n```\n\n```{.r .cell-code}\njonah_catch_theta_rho<- findSpeciesTheta_rho(complete_tidy_diff %>% filter(Species==\"jonah\") %>% na.omit(), type=\"catch\")\n```\n:::\n\n\nAnd repeat for the weight data:\n\n::: {.cell}\n\n```{.r .cell-code}\njonah_wtE <- findSpeciesE(complete_tidy_diff %>% filter(Species==\"jonah\") %>% na.omit(), type=\"wt\") \n```\n\n```{.r .cell-code}\njonah_wtE_rho<- findSpeciesErho(complete_tidy_diff %>% filter(Species==\"jonah\") %>% na.omit(), type=\"wt\")%>% round(digits=3)\n```\n\n```{.r .cell-code}\njonah_wt_theta<- findSpeciesTheta(complete_tidy_diff %>% filter(Species==\"jonah\") %>% na.omit(), type=\"wt\")\n```\n\n```{.r .cell-code}\njonah_wt_theta_rho<- findSpeciesTheta_rho(complete_tidy_diff %>% filter(Species==\"jonah\") %>% na.omit(), type=\"wt\")\n```\n:::\n\n\nLet's take a look:\n\n::: {.cell}\n\n```{.r .cell-code}\njonah_catchE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n    `1`   `2`   `3`   `4`\n  <dbl> <dbl> <dbl> <dbl>\n1     2     2     2     1\n2     2     2     2     1\n3     3     5     5     6\n4     2     6     2     3\n5     4     2     4     2\n```\n:::\n\n```{.r .cell-code}\njonah_catchE_rho\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n    `1`   `2`   `3`    `4`\n  <dbl> <dbl> <dbl>  <dbl>\n1 0.714 0.508 0.239  0.202\n2 0.573 0.382 0.464 -0.003\n3 0.385 0.344 0.274  0.572\n4 0.233 0.146 0.525  0.25 \n5 0.045 0.45  0.248  0.154\n```\n:::\n\n```{.r .cell-code}\njonah_catch_theta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n    `1`   `2`   `3`   `4`\n  <dbl> <dbl> <dbl> <dbl>\n1     2   1     7     8  \n2     7   1.5   1     9  \n3     1   1     9     3  \n4     9   9     4     3  \n5     1   2     0.3   0.5\n```\n:::\n\n```{.r .cell-code}\njonah_catch_theta_rho\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n     `1`   `2`   `3`   `4`\n   <dbl> <dbl> <dbl> <dbl>\n1 0.862  0.592 0.658 0.172\n2 0.600  0.801 0.749 0.140\n3 0.533  0.528 0.494 0.588\n4 0.454  0.441 0.456 0.419\n5 0.0915 0.533 0.378 0.742\n```\n:::\n\n```{.r .cell-code}\njonah_wtE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n    `1`   `2`   `3`   `4`\n  <dbl> <dbl> <dbl> <dbl>\n1     2     3     1     2\n2     3     2     2     1\n3     2     2     2     3\n4     1     6     2     2\n5     6     2     6     3\n```\n:::\n\n```{.r .cell-code}\njonah_wtE_rho\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n     `1`   `2`   `3`   `4`\n   <dbl> <dbl> <dbl> <dbl>\n1  0.707 0.227 0.16  0.193\n2  0.616 0.41  0.546 0.03 \n3  0.377 0.411 0.216 0.512\n4 -0.07  0.091 0.369 0.174\n5  0.178 0.645 0.271 0.43 \n```\n:::\n\n```{.r .cell-code}\njonah_wt_theta\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n    `1`   `2`   `3`   `4`\n  <dbl> <dbl> <dbl> <dbl>\n1  2      0.3  9     9   \n2  1      1.5  1     9   \n3  0.01   1    0.3   9   \n4  0.01   9    0.1   0.75\n5  2      5    0.01  9   \n```\n:::\n\n```{.r .cell-code}\njonah_wt_theta_rho\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n      `1`   `2`   `3`     `4`\n    <dbl> <dbl> <dbl>   <dbl>\n1  0.869  0.354 0.139  0.218 \n2  0.747  0.848 0.694 -0.0414\n3  0.605  0.626 0.435  0.576 \n4 -0.0843 0.300 0.420  0.522 \n5  0.398  0.704 0.352  0.662 \n```\n:::\n:::\n\n\nThe results for catch and weight are similar, but not identical. There is also clear spatial heterogeneity: some areas have an optimal embedding dimension of only 1, while others reach 6; some areas display essentially linear dynamics, with theta=0.01, but most areas appear to be highly nonlinear. The predictive skill also ranges widely. For example, Region 2, Stratum 4 appears especially low (catch s-map is 0.14, weight Simplex is 0.03, and catch Simplex and weight s-map have negative rho), whereas Region 1, Stratum 1 appears to be among the most predictable (all 4 models have rho >0.7). We note that the predictability for individual areas is generally higher than the aggregate results we computed earlier.\n\nThe lowered-number regions and strata (further south and closer inshore, respectively) appear to be generally more predictable than the outer strata and more northern regions. This seems reminiscent of the geographical area (in square miles) and number of tows allocated to each region/stratum combination. Let's test this by first creating data frames with the numbers from the ME-NH Inshore Trawl Survey protocols and procedures manual.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsq_miles <- data.frame(c(253.27, 279.63, 259.62, 205.3, 138.54), c(214.22, 191.23, 262.9, 206.12, 220.49), c(227.35, 211.66, 280.03, 310.49, 365.04), c(225.65, 263.49, 183.69, 170.72, 196.11))\ncolnames(sq_miles)<- colnames(jonah_catchE)\n\ntows_per_area <- data.frame(c(6, 7, 6, 5, 4), c(6, 5, 7, 5, 6), c(6, 6, 7, 8, 9), c(5, 5, 4, 4, 4))\ncolnames(tows_per_area)<- colnames(jonah_catchE)\n\nsq_miles_v <- c(as.matrix(sq_miles))\ntows_v <- c(as.matrix(tows_per_area))\n\njonah_catchE_v <- c(as.matrix(jonah_catchE))\njonah_catchE_rho_v <- c(as.matrix(jonah_catchE_rho))\njonah_catch_theta_v <- c(as.matrix(jonah_catch_theta))\njonah_catch_theta_rho_v <- c(as.matrix(jonah_catch_theta_rho))\njonah_wtE_v <- c(as.matrix(jonah_wtE))\njonah_wtE_rho_v <- c(as.matrix(jonah_wtE_rho))\njonah_wt_theta_v <- c(as.matrix(jonah_wt_theta))\njonah_wt_theta_rho_v <- c(as.matrix(jonah_wt_theta_rho))\n\ncorDf <- data.frame(sq_miles_v, tows_v, jonah_catchE_v, jonah_catchE_rho_v, jonah_catch_theta_v, jonah_catch_theta_rho_v, jonah_wtE_v, jonah_wtE_rho_v, jonah_wt_theta_v, jonah_wt_theta_rho_v)\nareaList <- c(11, 12, 13, 14, 21, 22, 23, 24, 31, 32, 33, 34, 41, 42, 43, 44, 51, 52, 53, 54)\n\nlibrary(corrplot)\ncorrplot(cor(corDf), method = \"circle\", order = 'hclust', type=\"lower\", diag=FALSE)\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n\n```{.r .cell-code}\ntestRes = cor.mtest(corDf, conf.level = 0.95, method=\"spearman\")\n\ncorrplot(cor(corDf), method = \"circle\", order = 'hclust', type=\"lower\", diag=FALSE, p.mat = testRes$p, sig.level = c(0.001, 0.01, 0.05), pch.cex = 0.9,\n         insig = 'label_sig', pch.col = 'grey20')\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-24-2.png){width=672}\n:::\n:::\n\n\nKey takeaways: \n(1) Weight E and catch E are positively correlated, as are weight theta and catch theta\n(2) Areas that were highly predictable using Simplex are more likely to be highly predictable using s-mapping\n(3) Within an abundance metric (catch or weight), the predictability of a system is not significantly correlated with its complexity (dimensionality) or linearity\n(4) The size of an area is not significantly correlated (using Spearman's method) with any of the other metrics besides number of tows, which is to be expected because tows were specifically allocated to ensure even density in all areas. Number of tows per area appeared correlated  with Simplex rho for catch data (positive correlation) and theta for weight data (negative correlation), but the strength of these correlations was relatively low, and it is likely that this is a case of statistical significance without practical/biological significance.\n\nWe will also look at these results when we average across regions or strata. \n# EDM dimensionality & nonlinearity - by region/stratum\nFirst, we'll define a function that takes in the name of a group and returns EDM stats on a data frame grouped appropriately:\n\n::: {.cell}\n\n```{.r .cell-code}\nfindSpeciesGroups_both<- function(df, species, type, g) {\n  df_out <- df %>% na.omit() %>% \n    filter(Type == type, Species == species) %>% \n    group_by(!!sym(g), date) %>% \n    summarise(avg = mean(value)) %>% \n    group_by(!!sym(g))  %>%\n    summarise(E_opt = findE_v(avg),\n              rho_E = findErho_v(avg),\n              Theta = findTheta_v(avg, E_opt),\n              rho_theta = findThetaRho_v(avg, E_opt))\n  return(df_out)\n}\n```\n:::\n\n\nNow we apply to the catch and weight data, looking at regional differences:\n\n::: {.cell}\n\n```{.r .cell-code}\njonah_catch_regions_stats<- findSpeciesGroups_both(complete_tidy_diff, type=\"catch\", g=\"Region\", species=\"jonah\")\n```\n\n```{.r .cell-code}\njonah_wt_regions_stats <- findSpeciesGroups_both(complete_tidy_diff, type=\"wt\", g=\"Region\", species=\"jonah\")\n```\n\n```{.r .cell-code}\njonah_catch_regions_stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 5\n  Region E_opt  rho_E Theta rho_theta\n  <fct>  <dbl>  <dbl> <dbl>     <dbl>\n1 1          2 0.156    9       0.751\n2 2          2 0.121    2       0.679\n3 3          4 0.103    0.3     0.213\n4 4          2 0.0898   1.5     0.101\n5 5          3 0.422    0.5     0.288\n```\n:::\n\n```{.r .cell-code}\njonah_wt_regions_stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 5\n  Region E_opt   rho_E Theta rho_theta\n  <fct>  <dbl>   <dbl> <dbl>     <dbl>\n1 1          2  0.240      9     0.863\n2 2          2  0.249      2     0.695\n3 3          2  0.323      9     0.474\n4 4          1 -0.0667     9     0.206\n5 5          3  0.277      9     0.238\n```\n:::\n:::\n\n\nDimensionality appears relatively consistent between regions, but predictability and nonlinearity appear to vary widely. As when we looked at individual areas earlier, the lower-numbered regions (further south) seem more predictable than the more northern regions when modeled with the appropriate nonlinear parameter (i.e., s-map with optimal theta). Is there a negative correlation between region and s-map predictability?\n\nWe use Spearman's method rather than the default Pearson's because Region is an ordinal variable and Pearson's requires at least interval data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Catch - s-map predictive skill\ncor.test(jonah_catch_regions_stats$rho_theta, as.numeric(jonah_catch_regions_stats$Region), method = \"spearman\", alternative = \"less\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tSpearman's rank correlation rho\n\ndata:  jonah_catch_regions_stats$rho_theta and as.numeric(jonah_catch_regions_stats$Region)\nS = 34, p-value = 0.1167\nalternative hypothesis: true rho is less than 0\nsample estimates:\n rho \n-0.7 \n```\n:::\n\n```{.r .cell-code}\n# rho = -0.7, p=0.117\n\n#Catch - nonlinearity\ncor.test(jonah_catch_regions_stats$Theta, as.numeric(jonah_catch_regions_stats$Region), method = \"spearman\", alternative = \"less\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tSpearman's rank correlation rho\n\ndata:  jonah_catch_regions_stats$Theta and as.numeric(jonah_catch_regions_stats$Region)\nS = 34, p-value = 0.1167\nalternative hypothesis: true rho is less than 0\nsample estimates:\n rho \n-0.7 \n```\n:::\n\n```{.r .cell-code}\n# rho = -0.7, p=0.117\n\n#Weight - s-map predictive skill\ncor.test(jonah_wt_regions_stats$rho_theta, as.numeric(jonah_wt_regions_stats$Region), method = \"spearman\", alternative = \"less\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tSpearman's rank correlation rho\n\ndata:  jonah_wt_regions_stats$rho_theta and as.numeric(jonah_wt_regions_stats$Region)\nS = 38, p-value = 0.04167\nalternative hypothesis: true rho is less than 0\nsample estimates:\n rho \n-0.9 \n```\n:::\n\n```{.r .cell-code}\n# rho = -0.9, p=0.042\n\n#Catch - show corr coefficients\ncorrplot(cor(data.frame(jonah_catch_regions_stats %>% mutate(Region = as.integer(Region))), method=\"spearman\"), method=\"number\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Catch - label significant correlations\ncorrplot(cor(data.frame(jonah_catch_regions_stats %>% mutate(Region = as.integer(Region)))), p.mat = \n           cor.mtest(jonah_catch_regions_stats %>% mutate(Region = as.integer(Region)), method=\"spearman\", alternative=\"less\")$p, insig = 'label_sig')\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-27-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#Weight - show corr coefficients\ncorrplot(cor(data.frame(jonah_wt_regions_stats %>% mutate(Region = as.integer(Region))), method=\"spearman\"), method=\"number\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-27-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# Weight - label significant correlations\ncorrplot(cor(data.frame(jonah_wt_regions_stats %>% mutate(Region = as.integer(Region)))), p.mat = \n           cor.mtest(jonah_wt_regions_stats %>% mutate(Region = as.integer(Region)), method=\"spearman\", alternative=\"less\")$p, insig = 'label_sig')\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-27-4.png){width=672}\n:::\n\n```{.r .cell-code}\n#both weight and catch, to increase sample size\ncorrplot(cor(data.frame(rbind(jonah_wt_regions_stats, jonah_catch_regions_stats) %>% mutate(Region = as.integer(Region))), method=\"spearman\"), method=\"number\")\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-27-5.png){width=672}\n:::\n\n```{.r .cell-code}\ncorrplot(cor(data.frame(rbind(jonah_wt_regions_stats, jonah_catch_regions_stats) %>% mutate(Region = as.integer(Region)))), p.mat = \n           cor.mtest(rbind(jonah_wt_regions_stats, jonah_catch_regions_stats) %>% mutate(Region = as.integer(Region)), method=\"spearman\", alternative=\"less\")$p, insig = 'label_sig')\n```\n\n::: {.cell-output-display}\n![](jonahMethods_files/figure-html/unnamed-chunk-27-6.png){width=672}\n:::\n:::\n\n\nS-map predictability is indeed strongly negatively correlated with region. Although the combined correlation plot also shows a significant negative correlation between E and theta, this is only driven by the catch data and is not present in the weight data. The only clear strong association present in both sets of data is the negative relationship between region and nonlinear predictive skill.\n\nOn to strata:\n\n::: {.cell}\n\n```{.r .cell-code}\njonah_catch_strat_stats<- findSpeciesGroups_both(complete_tidy_diff, type=\"catch\", g=\"Stratum\", species=\"jonah\")\n```\n\n```{.r .cell-code}\njonah_wt_strat_stats <- findSpeciesGroups_both(complete_tidy_diff, type=\"wt\", g=\"Stratum\", species=\"jonah\")\n```\n\n```{.r .cell-code}\njonah_catch_strat_stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  Stratum E_opt rho_E Theta rho_theta\n  <fct>   <dbl> <dbl> <dbl>     <dbl>\n1 1           2 0.225   1.5     0.479\n2 2           3 0.160   9       0.201\n3 3           2 0.341   1.5     0.563\n4 4           2 0.160   1       0.692\n```\n:::\n\n```{.r .cell-code}\njonah_wt_strat_stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n  Stratum E_opt rho_E Theta rho_theta\n  <fct>   <dbl> <dbl> <dbl>     <dbl>\n1 1           2 0.186   1       0.494\n2 2           3 0.217   9       0.156\n3 3           2 0.276   1       0.542\n4 4           2 0.281   1.5     0.610\n```\n:::\n:::\n\n\nFor each stratum, the values computed from the weight data were very similar to those computed from the catch data. Simplex projection using the disparate abundance metrics identified identical embedding dimension values, rho values generally within <0.1 of each other, and concurring measures of nonlinearity: theta between 1-1.5 for strata 1, 3, and 4, with theta=9 for stratum 2. This provides a reassuring indication that the method is robust to at least small amounts of observation noise and/or slightly different ways of \"viewing\" the attractor manifold of the system.\n\nAfter our analysis of the univariate dynamics of the Jonah crab fishery at multiple spatial scales, we can feel confident that it has the low-dimensional, nonlinear dynamics that make CCM an appropriate method of determining causality.\n\n# Convergent cross-mapping\nAs with the univariate analysis, we will start by averaging across all spatial scales. Previously, we identified E=2 to be the optimal embedding dimension for the overall Jonah crab population for both catch and weight, so we will use that value for cross-mapping.\n\nHowever, since we will also be attempting to predict the target species (scallops or rock crabs) from Jonah crab abundance, we will need to identify the appropriate E and theta for the target populations as well. The CCM function automatically computes cross-map skill in both directions, but we will be repeating the function calls twice: once with E optimized for Jonah and once with E optimized for the target. Hopefully, the two calls will produce similar results, and the combined result will give us a better picture of strong interspecies relationships that are robust to slight misspecifications of the function.\n\nFirst, we'll define a function that adds a new column with the direction for which we optimized the cross-mapping, and a vector containing the different combinations we'll be trying.\n\n::: {.cell}\n\n```{.r .cell-code}\naddDirection <- function(df) {\n  df_out <- df %>% \n    mutate(xmap = case_when(predator==\"jonah\" & prey==\"scallop\" & direction==\"predator -> prey\" ~ \"jonah -> scallop\",\n                            predator==\"jonah\" & prey==\"scallop\" & direction==\"prey -> predator\" ~ \"scallop -> jonah\",\n                            predator==\"jonah\" & prey==\"rock\" & direction==\"predator -> prey\" ~ \"jonah -> rock\",\n                            predator==\"jonah\" & prey==\"rock\" & direction==\"prey -> predator\" ~ \"rock -> jonah\"))\n  return(df_out)\n}\n\ncombos <- c(\"jonah:scallop\", \"scallop:jonah\", \"jonah:rock\",\"rock:jonah\")\n```\n:::\n\n\nFirst, filter the second-differenced data frame to create the more specific data frames needed for CCM analysis:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Catch only\ncatchCCMdf <- catch_complete_diff %>% ungroup() %>% na.omit() %>% \n  select(date, Region, Stratum, area, avgCatch_s, avgCatch_r, avgCatch_j) %>% \n  rename(rock = avgCatch_r , scallop = avgCatch_s , jonah= avgCatch_j)  %>% \n  mutate(area = as.integer(paste0(Region, Stratum)))\n\n# Weight only\nwtCCMdf <- catch_complete_diff %>% ungroup() %>% na.omit() %>% \n  select(date, Region, Stratum, area, avgWt_s, avgWt_r, avgWt_j) %>% \n  rename(rock = avgWt_r , scallop = avgWt_s , jonah= avgWt_j)  %>% \n  mutate(area = as.integer(paste0(Region, Stratum)))\n\ncatchCCMdf_agg <- catchCCMdf %>% group_by(date) %>% summarise(across(scallop:jonah, mean))\nwtCCMdf_agg <- wtCCMdf %>% group_by(date) %>% summarise(across(scallop:jonah, mean))\n```\n:::\n\n\nWe also create",
    "supporting": [
      "jonahMethods_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
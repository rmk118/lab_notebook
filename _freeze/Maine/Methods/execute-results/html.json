{
  "hash": "1e5bacd5d64a5d5b3a52150e0da80404",
  "result": {
    "markdown": "---\ntitle: 'Methods'\ndate: '2023-07-14'\nexecute: \n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n#bibliography: references.bib\n---\n\n\nRuby Krasnow\nLast modified: July 14, 2023\n\nLoad packages\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(lubridate) #date formatting\nlibrary(patchwork) #combining plots\nlibrary(tseries) #for KPSS test for stationarity\nlibrary(rEDM) #EDM\n\n#spatial packages\nlibrary(sf)\nlibrary(sfheaders)\nlibrary(spdep)\n```\n:::\n\n\n\n\n# Organize data\nAnalysis was performed on the catch weight (kg) of each species, which was recorded for each tow and standardized by DMR to account for tows that were longer or shorter than the 1 NM standard. \n\n::: {.cell}\n\n```{.r .cell-code}\ndf_tows<-read.csv(\"~/Downloads/lab_notebook/data/Maine_inshore_trawl/MEtows.csv\") #tow data\ndf_s_cat<- read.csv(\"~/Downloads/lab_notebook/data/Maine_inshore_trawl/MEscallopCatch.csv\") #scallop catch\ndf_r_cat<- read.csv(\"~/Downloads/lab_notebook/data/Maine_inshore_trawl/MErockCatch.csv\") #rock crab catch\ndf_j_cat<- read.csv(\"~/Downloads/lab_notebook/data/Maine_inshore_trawl/MEjonahCatch.csv\") #jonah crab catch\n```\n:::\n\n\n## Log-transform, summarize, and assess stationarity\nAll data was log transformed to reduce nonstationarity, which was assessed for each study area using the Kwiatkowski-Phillips-Schmidt-Shin (KPSS) test (Kwiatkowski et al., 1992).\n\n::: {.cell}\n\n```{.r .cell-code}\n# cleanCatch function includes log transformation; see helpFunctionsMaine script for details\n\ns_cat_clean <- cleanCatch(df_s_cat) %>% \n  mutate(Common_Name = \"Scallop\")\n\nr_cat_clean <- cleanCatch(df_r_cat) %>% \n  mutate(Common_Name = \"Rock\")\n\nj_cat_clean <- cleanCatch(df_j_cat) %>% \n  mutate(Common_Name = \"Jonah\")\n\n#Reorder columns\ncolOrder<-c(\"area\", \"Survey\", \"Tow_Number\", \"Region\", \"Stratum\", \"logCatch\", \"logWt\", \"Expanded_Catch\", \n  \"Expanded_Weight_kg\", \"Date\", \"Common_Name\", \"Number_Caught\", \"Weight_kg\",\n  \"Start_Latitude\", \"Start_Longitude\",\"Season\",\n  \"Year\",\"Grid\", \"Start_Depth_fathoms\", \"End_Depth_fathoms\",\n  \"Bottom_WaterTemp_DegC\", \"Bottom_Salinity\")\n\nj_cat_clean <- j_cat_clean %>% select(all_of(colOrder))\nr_cat_clean <- r_cat_clean %>% select(all_of(colOrder))\ns_cat_clean <- s_cat_clean %>% select(all_of(colOrder))\n\n#computes averages for each study area (area = region-stratum combination)\nj_cat_sum <- summaryCatch(j_cat_clean)\nr_cat_sum <- summaryCatch(r_cat_clean)\ns_cat_sum <- summaryCatch(s_cat_clean)\n\ncatch <- s_cat_sum %>% left_join(j_cat_sum, by=c(\"area\", \"Season\", \"Region\", \"Stratum\", \"Year\"), suffix = c(\"_s\", \"_j\"))\ncatch <- catch %>% left_join(r_cat_sum, by=c(\"area\", \"Season\", \"Region\", \"Stratum\", \"Year\")) %>% \n  mutate(avgCatch_r = avgCatch,avgWt_r = avgWt,avgLogCatch_r = avgLogCatch,avgLogWt_r = avgLogWt, .keep=\"unused\")\n\ncatchTidy <- pivot_longer(catch, \n        cols = 6:ncol(catch)) %>% \n  mutate(Type = case_when(\n    startsWith(name, \"avgCatch_\") ~\"catch\",\n    startsWith(name,\"avgWt_\") ~\"wt\",\n    startsWith(name,\"avgLogWt\") ~\"logWt\",\n    startsWith(name,\"avgLogCatch\") ~\"logCatch\")) %>% \n  mutate(Species = case_when(\n    endsWith(name, \"s\") ~\"scallop\",\n    endsWith(name, \"r\") ~\"rock\",\n    endsWith(name, \"j\") ~\"jonah\"))\n\ncatchTidy <- catchTidy %>% mutate(area = as.factor(area), Species = as.factor(Species),Season = as.factor(Season),Region = as.factor(Region), Stratum = as.factor(Stratum)) %>% \n          select(-name)\n\nlogCatchFall <- catchTidy %>% filter(Type == \"logCatch\") %>% filter(Season == \"Fall\")\nlogWtFall <- catchTidy %>% filter(Type == \"logWt\") %>% filter(Season == \"Fall\")\n\n#Note that the highest p-value the kpss.test function will show is 0.1, actual p-values may be higher\nfindSpeciesKPSS(logCatchFall %>% filter(Species==\"scallop\"), season=\"Fall\", type=\"logCatch\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n     `1`    `2`    `3`   `4`\n   <dbl>  <dbl>  <dbl> <dbl>\n1 0.1    0.1    0.1      0.1\n2 0.1    0.0383 0.0237   0.1\n3 0.1    0.0248 0.0177   0.1\n4 0.1    0.0539 0.01     0.1\n5 0.0766 0.0776 0.1      0.1\n```\n:::\n\n```{.r .cell-code}\nfindSpeciesKPSS(logCatchFall %>% filter(Species==\"rock\"), season=\"Fall\", type=\"logCatch\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n    `1`    `2`   `3`      `4`\n  <dbl>  <dbl> <dbl>    <dbl>\n1   0.1 0.1      0.1 NaN     \n2   0.1 0.0497   0.1   0.1   \n3   0.1 0.0347   0.1   0.1   \n4   0.1 0.0432   0.1   0.0914\n5   0.1 0.1      0.1   0.1   \n```\n:::\n\n```{.r .cell-code}\nfindSpeciesKPSS(logCatchFall %>% filter(Species==\"jonah\"), season=\"Fall\", type=\"logCatch\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n     `1`   `2`   `3`   `4`\n   <dbl> <dbl> <dbl> <dbl>\n1 0.0223   0.1   0.1   0.1\n2 0.0646   0.1   0.1   0.1\n3 0.1      0.1   0.1   0.1\n4 0.1      0.1   0.1   0.1\n5 0.1      0.1   0.1   0.1\n```\n:::\n\n```{.r .cell-code}\nfindSpeciesKPSS(logWtFall %>% filter(Species==\"scallop\"), season=\"Fall\", type=\"logWt\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n     `1`    `2`    `3`    `4`\n   <dbl>  <dbl>  <dbl>  <dbl>\n1 0.0794 0.0948 0.1    0.1   \n2 0.1    0.0674 0.0528 0.1   \n3 0.1    0.0385 0.0428 0.1   \n4 0.1    0.0410 0.0149 0.0495\n5 0.0689 0.1    0.1    0.1   \n```\n:::\n\n```{.r .cell-code}\nfindSpeciesKPSS(logWtFall %>% filter(Species==\"rock\"), season=\"Fall\", type=\"logWt\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n     `1`    `2`    `3`      `4`\n   <dbl>  <dbl>  <dbl>    <dbl>\n1 0.1    0.1    0.1    NaN     \n2 0.0372 0.0881 0.1      0.1   \n3 0.1    0.0183 0.1      0.1   \n4 0.1    0.1    0.0932   0.0832\n5 0.1    0.1    0.1      0.1   \n```\n:::\n\n```{.r .cell-code}\nfindSpeciesKPSS(logWtFall %>% filter(Species==\"jonah\"), season=\"Fall\", type=\"logWt\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n     `1`    `2`   `3`   `4`\n   <dbl>  <dbl> <dbl> <dbl>\n1 0.0303 0.1      0.1   0.1\n2 0.0439 0.0979   0.1   0.1\n3 0.1    0.1      0.1   0.1\n4 0.1    0.1      0.1   0.1\n5 0.1    0.1      0.1   0.1\n```\n:::\n:::\n\n\n# Question 1: Do the intensity and pattern of spatial autocorrelation indicate spatial bootstrapping could be an appropriate method?\n\nFirst, import the location data for the survey region (surveyGrid) and transform the catch dataframes into sf objects for spatial analysis, using the same CRS as the survey grid.\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveyGrid <-st_read(\"~/Downloads/lab_notebook/Maine/MaineDMR_-_Inshore_Trawl_Survey_Grid/\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `MaineDMR_-_Inshore_Trawl_Survey_Grid' from data source \n  `/Users/rubykrasnow/Downloads/lab_notebook/Maine/MaineDMR_-_Inshore_Trawl_Survey_Grid' \n  using driver `ESRI Shapefile'\nSimple feature collection with 3698 features and 9 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -70.81288 ymin: 42.86466 xmax: -66.88822 ymax: 44.81316\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\n#CRS: WGS 84/EPSG 4326\n\nsurveyGrid <- surveyGrid %>% \n  mutate(Region = region_id,\n         Stratum = depth_stra,\n         GridID = grid_id, .keep=\"unused\", .before=last_surve)\n\nsurveyGrid$region_stratum <- paste(surveyGrid$Region, surveyGrid$Stratum)\n\nggplot(surveyGrid)+geom_sf()\n```\n\n::: {.cell-output-display}\n![](Methods_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\ns_cat_sf <- st_as_sf(s_cat_clean, coords = c(\"Start_Longitude\", \"Start_Latitude\"), crs=4326)\nr_cat_sf <- st_as_sf(r_cat_clean, coords = c(\"Start_Longitude\", \"Start_Latitude\"), crs=4326)\nj_cat_sf <- st_as_sf(j_cat_clean, coords = c(\"Start_Longitude\", \"Start_Latitude\"), crs=4326)\n\n# Map of all points over grid\nggplot() + geom_sf(data = surveyGrid) + geom_sf(data = s_cat_sf)\n```\n\n::: {.cell-output-display}\n![](Methods_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\nMerge the individual survey grids into one region\n\n::: {.cell}\n\n```{.r .cell-code}\nmergedGrid <- st_union(surveyGrid, by_feature = FALSE) %>% st_sf()\nmergedGridBuffer <- st_buffer(mergedGrid, 9000)\nggplot(mergedGridBuffer)+geom_sf()\n```\n\n::: {.cell-output-display}\n![](Methods_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nFirst, Voronoi polygons were constructed around each data point.\n\n::: {.cell}\n\n```{.r .cell-code}\nvoronoiScal <- s_cat_sf %>%\n  st_geometry() %>% # to get sfc from sf\n  st_union() %>% # to get a sfc of MULTIPOINT type\n  st_voronoi() %>% #\n  st_collection_extract(type = \"POLYGON\") %>% # a list of polygons\n  st_sf() %>% # from list to sf object\n  st_intersection(mergedGridBuffer) %>%\n  st_join(s_cat_sf)  # put names back\n\nplot(voronoiScal$geometry)\n```\n\n::: {.cell-output-display}\n![](Methods_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\nCalculate Global Moran's I\n\n::: {.cell}\n\n```{.r .cell-code}\n#Create a list of neighbors for each polygon\nnb <- poly2nb(voronoiScal, queen = TRUE) # queen shares point or border\nnbw <- nb2listw(nb, style = \"W\") #creates a weighted list (e.g., if a polygon has 4 neighbors, each neighbor receives a weight of 0.25)\n\n# Global Moran's I - used more robust Monte Carlo method rather than the analytical method\ngmoranScal <- moran.mc(voronoiScal$logCatch, nbw, nsim=999, alternative=\"greater\")\ngmoranScal\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  voronoiScal$logCatch \nweights: nbw  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.29948, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n\n```{.r .cell-code}\ngmoranScalWt <- moran.mc(voronoiScal$logWt, nbw, nsim=999, alternative=\"greater\")\ngmoranScalWt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  voronoiScal$logWt \nweights: nbw  \nnumber of simulations + 1: 1000 \n\nstatistic = 0.18433, observed rank = 1000, p-value = 0.001\nalternative hypothesis: greater\n```\n:::\n:::\n\n\n\nCalculate and display Local Moran's I\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlmoran <- localmoran(voronoiScal$logCatch, nbw, alternative = \"greater\")\nhead(lmoran)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Ii          E.Ii     Var.Ii       Z.Ii Pr(z > E(Ii))\n1  0.25167493 -6.672188e-05 0.06288115  1.0039101     0.1577110\n2 -0.17850185 -6.672188e-05 0.06288115 -0.7115741     0.7616357\n3  0.10542204 -6.672188e-05 0.04189852  0.5153554     0.3031523\n4 -0.53470594 -6.672188e-05 0.04189852 -2.6119298     0.9954984\n5  0.07617146 -6.672188e-05 0.05029157  0.3399577     0.3669442\n6  0.25167493 -6.672188e-05 0.06288115  1.0039101     0.1577110\n```\n:::\n\n```{.r .cell-code}\nlmoranWt <- localmoran(voronoiScal$logWt, nbw, alternative = \"greater\")\nhead(lmoranWt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Ii          E.Ii     Var.Ii       Z.Ii Pr(z > E(Ii))\n1  0.08712977 -2.309909e-05 0.02177038  0.5906751     0.2773691\n2 -0.13287330 -2.309909e-05 0.02177038 -0.9003870     0.8160428\n3  0.07272997 -2.309909e-05 0.01450588  0.6040588     0.2729023\n4 -0.25367845 -2.309909e-05 0.01450588 -2.1060658     0.9824007\n5  0.06985001 -2.309909e-05 0.01741168  0.5295289     0.2982193\n6  0.08712977 -2.309909e-05 0.02177038  0.5906751     0.2773691\n```\n:::\n\n```{.r .cell-code}\nvoronoiScal$lmI <- lmoran[, \"Ii\"] # local Moran's I - catch\nvoronoiScal$lmIwt <- lmoranWt[, \"Ii\"] # local Moran's I - weight\nvoronoiScal$lmZ <- lmoran[, \"Z.Ii\"] # z-scores - catch\nvoronoiScal$lmZwt <- lmoranWt[, \"Z.Ii\"] # z-scores - weight\n\n# p-values corresponding to alternative greater\nvoronoiScal$lmp <- lmoran[, \"Pr(z > E(Ii))\"] #catch\nvoronoiScal$lmpWt <- lmoranWt[, \"Pr(z > E(Ii))\"] #weight\n\ncatchPlot <- ggplot(voronoiScal)+geom_sf(aes(fill=logCatch))+scale_fill_viridis_c(option = \"D\")+theme_bw()\nmoranPlotZ <- ggplot(voronoiScal)+geom_sf(aes(fill=lmZ))+scale_fill_viridis_c(option = \"G\", name=\"Local Moran's I\\nZ-score (catch)\")+theme_bw()\n\nwtPlot <- ggplot(voronoiScal)+geom_sf(aes(fill=logWt))+scale_fill_viridis_c(option = \"D\")+theme_bw()\nmoranPlotWtZ <- ggplot(voronoiScal)+geom_sf(aes(fill=lmZwt))+scale_fill_viridis_c(option = \"G\", name=\"Local Moran's I\\nZ-score (weight)\")+theme_bw()\n\ncatchPlot + moranPlotZ + wtPlot + moranPlotWtZ + plot_annotation(tag_levels = 'A') + plot_layout(tag_level = 'new') & \n  theme(plot.tag = element_text(size = 12, vjust = 6))\n```\n\n::: {.cell-output-display}\n![](Methods_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n# Question 2: Does spatial replication using neighboring points preserve the dimensionality and nonlinearity of a system?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate the average number of tows per area over the whole time series\n# there are a few years where there is one more tow for scallops than for the crab species\nnumTows<- (s_cat_clean %>% group_by(area) %>% summarise(num = n_distinct(row_number())))\nnumTowsCrabs<- (r_cat_clean %>% group_by(area) %>% summarise(num = n_distinct(row_number())))\n```\n:::\n\n\nTo demonstrate our spatial resampling method, we will take study area 1.1 (Region 1, Stratum 1) as an example:\nData points marked as being in 1.1 form the 'base' area\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "Methods_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}